گام ۲ - یک تابع:  در ابتدا به بررسی تابع memparse در kernel v3.14.79 پرداختیم. وظیفه‌ی کلی این این تابع تبدیل یک string به یک عدد بدون علامت (long long) است. نحوه‌ی کار آن این است که با صدا کردن تابع simple_strtoull قسمت عددی را بدست می‌آورد سپس به اولین حرف پس از عدد نگاه می‌کند و با توجه به اینکه گیگ، مگ یا کیلو است به تعداد لازم عدد را شیفت می‌دهد. در آخر اگر پوینتری برای رشته‌ی بعدی داده شده باشد (تعریف شده باشد، null نباشد) انتهای این رشته را به عنوان ابتدای‌ بعدی در نظر می‌گیرد و مقدار تبدیل شده را برمی‌گرداند. 
Memparse: return value: unsigned long long عدد تبدیل شده parameters: پوینتری به شروع این رشته و اشاره‌گری به پوینتر شروع رشته‌ی بعدی
همان طور که گفتیم تابع simple_strtoull در این تابع صدا می‌شد. به طور خلاصه این تابع مبنای رشته‌ی داده شده را با استفاده از تابع simple_guess_base پیدا می‌کرد و بعد با توجه به مبنا رشته را  به عدد تبدیل می‌کند. در صورتی که مبنا ۱۶ باشد اشاره‌گر به سر رشته را ۲ تا جلو می‌برد. (تا از 0x اول بگذرد). سپس با استفاده از تابع isxdigit برای هر کاراکتر در رشته شرط رقم بودن در آن مبنا را بررسی می‌کند،‌ اگر شرط برقرار  بود و رقم از مبنا بزرگتر نبود، آن را به معادل عددی‌اش در مبنای ۱۰ تبدیل می‌کند و تا انتهای رشته ادامه می‌دهد. اگرisxdigit برقرار نبود ادامه‌ی رشته را به عنوان بخشی از عدد در نظر نمی‌گیرد.  
Simple_strtoull: return value: unsigned long long: عدد تبدیل شده بدون در نظر گرفتن بزرگی(M, G, K) parameters: cp=اشاره‌گری به شروع رشته endp = اشاره‌گری به پوینتر به اولین حرف پس از عدد که البته در تابع مقدار دهی می‌شود و زمانی که به عنوان پارامتر داده شده، صرفا تعریف شده است 
base= مبنای رشته‌ای است که می‌خواهیم تبدیل کنیم که هر بار ۰ داده می‌شود تا خود تابع مقدار آن را محاسبه کند
همان طور که گفتیم این تابع، تابع simple_guess_base را صدا می‌کرد. که این تابع مبنا را حدس می‌زند. به این صورت که اگر کاراکتر اول رشته ۰ باشد و کاراکتر دوم × باشد و کاراکتر بعدی از ارقام مجاز مبنای ۱۶ باشد مبنا را ۱۶ اعلام می‌کند، در غیر این صورت اگر فقط کاراکتر اول ۰ باشد ولی حتی یکی از ۲ شرط دیگر برقرار نباشد مبنا را ۸ اعلام می‌کند و اگر کلا کاراکتر اول ۰ نباشد مبنا را ۱۰ اعلام می‌کند. این تابع برای انجام این کار‌ها از تابع isxdigit کمک می‌گیرد. 
Simple_guess_base: return value: unsigned int مبنا parameters: cp = اشاره‌گر به ابتدای رشته 
تابع isxdigit که بالاتر از آن استفاده شد 
گام سوم - بخش صفر: کلمه‌ی بوت در کامپیوتر به معنی load شدن سیستم‌عامل در حافظه‌ی اصلی و یا رَم کامپیوتر است. پس از اینکه سیستم‌عامل load شد آماده‌ی اجرای برنامه‌ها توسط کاربران است. (منبع: http://searchwindowsserver.techtarget.com/definition/boot) بوت شدن با توجه به منابع دارای ۵ مرحله (یا ۶) است: ۱- BIOS: این کلمه خلاصه‌ی basic input/output system است. پس از فشردن دکمه روشن شدن cpu درROM به دنبال دستوری که باید اجرا کند می‌گردد، ROM شامل دستور پرش است که cpu را به بخش BIOS می‌برد. در BIOS لیست تمام ابزارهای ورودی و خروجی موجود برای سیستم وجود دارد. و در واقع BIOS مراحل شروع کار سخت‌افزارهای خاص سیستم را انجام می‌دهد، زمانی که سخت‌افزارهای واجب برای بوت شدن initialize شدند به مرحله‌ی بعدی می‌رویم. ۲- Boot loader: Boot loader که به اسم boot system نیز شناخته می‌شود در واقع برنامه‌ی کوچکی است که سیستم‌عامل را در حافظه قرار می‌دهد و کنترل را به آن می‌سپارد. این برنامه اغلب منو‌ای از گزینه‌های بوت موجود را به کاربر نشان می‌دهد، در صورت انتخاب نشدن چیزی توسط کاربر یا نبودن بیش از یک گزینه، Boot loader کرنل را در حافظه load می‌کند. خود  Boot loader شامل ۲ بخش است. + MBR = master boot record: این sector اول هارد دیسک است که ۵۱۲ بایت از آن را اشغال می‌کند. که حدود ۴۳۰ بایت اول آن Boot loader اولیه است. ۶۴ بایت بعدی آن به partition table تعلق دارد. یک partition table یک ساختار داده است که اطلاعاتی را برای سیستم‌عامل درباره‌ی تقسیم‌بندی (بخش‌بندی) هارد دیسک به بخش‌های اصلی‌اش می‌دهد. ۶ بایت بعدی نیز به MBR validation timestamp متعلق است. MBR در واقع GRUB که بخش دیگرBoot loader است را load و اجرا می‌کند. (از آنجایی MBR به مفاهیم و اطلاعات فایل سیستم‌ها آگاه نیست نمی‌تواند به طور مستقیم کرنل را لود کند. برای اطلاع درباره‌ی فایل سیستم‌ها در لینوکس به لینک http://www.tldp.org/LDP/intro-linux/html/sect_03_01.html مراجعه کردیم.). + GRUB = Grand unified boot loader: بخش ۱.۵ گراب در ۳۰ کیلوبایت پس از MBR و قبل از بخش‌بندی ۱ هارد دیسک قرار دارد که اطلاعات مربوط به deriver و module های فایل سیستم‌ها را در خود نگه‌می‌دارد. بخش ۲ از گراب وظیفه‌ی load کردن کرنل را دارد. در این بخش است که لیست کرنل‌ها در صورت وجود برای کاربر نمایش داده می‌شود. پس از این مرحله کنترل به کرنل داده می‌شود. ۳- Kernel: کرنل درصورتی که به صورت فشرده شده باشد خود را از این حالت خارج کرده و سریعا configurationهای مربوط به سخت‌افزار و اختصاص دادن حافظه به سیستم‌ را انجام می‌دهد. 
 (منابع:    https://en.wikipedia.org/wiki/Linux_startup_process - http://www.golinuxhub.com/2014/03/step-by-step-linux-boot-process.html -  http://www.linfo.org/partition_table.htm l   http://linuxlecture.com/boot-process-in-linux/ - http://searchdatacenter.techtarget.com/definition/boot-loader-boot-manager)


 
گام سوم - سوال ۲: به سراغ تابع main در arch/x86/boot/main.c/ رفتیم،  
گام چهارم-حالت های مختلف سیستم
User mode and kernel mode
:Kernel mode
در حالت کرنل کد در حال اجرا دسترسی کامل و بدون محدودیت به سخت افزار پایه  دارد. این حالت میتواند هر دستورcpu را اجرا کند و هر آدرس حافظه ای را ارجاع دهد.کرنل مود به طور کلی برای توابع سطح پایین و با قابلیت اعتماد بالا سیستم عامل مورد استفاده می شود.crashدر کرنل مود فاجعه آفرین است و میتواند pcرا متوقف کند.
User mode:
در حالت یوزر مود کد در حال اجرا توانایی دسترسی مستقیم به سخت افزار یا ارجاع حافظه ندارد.کد درحال اجرا باید دسترسی به سخت افزار و یا حافظه را به APIهای سیستم محول کند.با توجه به حفاظت ها و پروتکت هایی که در این حالت انجام میشود،crash در یوزر مود همیشه قابل بازیابی و حل شدن است.
منبع: https://blog.codinghorror.com/understanding-user-and-kernel-mode/
بسته به کد در حال اجرا پردازنده بین این دو حالت سوییچ میکند. به طور کلی برنامه ها در یوزر مود و اجزای اصلی سیستم عامل در کرنل مود اجرا میشوند.در حالی که بیشتر درایور ها در حالت کرنل اجرا میشوند اما بعضی از درایور ها نیز ممکن است در حالت یوزر اجرا شوند.زمانی که از یک برنامه ی یوزر مود استفاده میکنیم؛سیستم عامل یک فرایندی برای آن برنامه ایجاد میکند.این فرایند برای برنامه یک فضای آدرس مجازی خصوصی ویک جدول مدیریت خصوصی فراهم میکند.به علت این خصوصی بودن فضای آدرس مجازی برنامه  یک برنامه نمیتواند داده ای را که مربوط به برنامه ی  دیگر است تغییر دهد.هر برنامه به صورت مجزا انجام میشود و این مسئله باعث میشود اگر در یک برنامه crashاتفاق افتاد برنامه  های دیگر تحت تاثیر آن قرار نگیرند.
تمام کدهایی که در کرنل مود اجرا می شوند؛یک فضای آدرس مجازی واحد را به اشتراک میگذارند.این مسئله به این معنی است که driver  کرنل مود از سایر driver ها و سیستم عامل جدا نیست.اگر یک driver  کرنل مود به صورت تصادفی در آدرس مجازی اشتباه بنویسد؛داده ای که متعلق به سیستم عامل و یا سایر driver ها است ممکن است به خطر بیفتد.اگر یک driverدر حالت کرنل مود دچار crashشود؛کل سیستم عامل دچار crashمیشود.تصویر زیر ارتباط بین یورز مود و اجزای کرنل مود را نشان میدهد:




منبع:https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode
		

Real mode:
نسخه ی اورجینال IBM PC فقط میتوانسته 1MB از حافظه ی سیستم را آدرس دهی کند و نسخه های اصلی DOS که برای کار روی این طراحی شده بودند با این فرض طراحی شده بودند. DOS به طور ذاتی یک سیستم عامل single-tasking می باشد یعنی فقط اجرای یک برنامه را در زمان میتواند هندل(handle) کند.این تصمیم تا الان ادامه داشته تا بتوان سیستم عامل را در یک حالت قرار داد که بتواند با original Intel 8088 chip کار کند.
همه ی processorها حالت real را دارند ولی در واقع DOS و برنامه های استاندارد DOS از این حالت استفاده میکردند.


Protected mode:
این حالت بسیار قوی تر از حالت real میباشد و در تمام سیستم عامل های multitasking استفاده میشود.در این حالت دسترسی کامل به حافظه ی سیستم موجود میباشد.توانایی مدیریت اجرای هم زمان چند برنامه وجود دارد(multitasking). پشتیبانی از Virtual memory که به سیستم این اجازه را میدهد تا درصورت نیاز به حافظه بیشتر از هارد دیسک استفاده کند.دسترسی سریعتر  به حافظه و درایور سریعتر برای انتقال I/O .
اسم protected از آن جا آمده که هر کاری که بخواهد اجرا بشود حافظه ی assignشده به خود را دارد و از برخورد با دیگر برنامه ها جلوگیری میکند.
پس تفاوت های کلیدی این دو حالت در میزان دسترسی به حافظه و سرعت آن میباشد.علاوه بر این در حالت real سیستم عامل به صورت single task عمل میکند اما در حالت protected به صورت multitask کار میکند.
