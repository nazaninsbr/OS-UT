{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf830
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red26\green23\blue24;\red19\green156\blue235;\red0\green0\blue0;
}
{\*\expandedcolortbl;;\cssrgb\c13725\c12157\c12549;\cssrgb\c0\c67843\c93725;\cssrgb\c0\c0\c0;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl300\sa240\partightenfactor0

\f0\fs26\fsmilli13333 \cf2 \expnd0\expndtw0\kerning0
One of the most important aspects of operating systems is the ability to multiprogram. A single program cannot, in general, keep either the 
\fs24 CPU 
\fs26\fsmilli13333 or the 
\fs24 I/O 
\fs26\fsmilli13333 devices busy at all times. Single users frequently have multiple programs running. 
\b \cf3 Multiprogramming 
\b0 \cf2 increases 
\fs24 CPU 
\fs26\fsmilli13333 utilization by organizing jobs (code and data) so that the 
\fs24 CPU 
\fs26\fsmilli13333 always has one to execute. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 The idea is as follows: The operating system keeps several jobs in memory simultaneously (Figure 1.9). Since, in general, main memory is too small to accommodate all jobs, the jobs are kept initially on the disk in the 
\b \cf3 job pool
\b0 \cf2 . This pool consists of all processes residing on disk awaiting allocation of main memory. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 The set of jobs in memory can be a subset of the jobs kept in the job pool. The operating system picks and begins to execute one of the jobs in memory. Eventually, the job may have to wait for some task, such as an 
\fs24 I/O 
\fs26\fsmilli13333 operation, to complete. In a non-multiprogrammed system, the 
\fs24 CPU 
\fs26\fsmilli13333 would sit idle. In a multiprogrammed system, the operating system simply switches to, and executes, another job. When 
\i\b that 
\i0\b0 job needs to wait, the 
\fs24 CPU 
\fs26\fsmilli13333 switches to 
\i\b another 
\i0\b0 job, and so on. Eventually, the first job finishes waiting and gets the 
\fs24 CPU 
\fs26\fsmilli13333 back. As long as at least one job needs to execute, the 
\fs24 CPU 
\fs26\fsmilli13333 is never idle. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 This idea is common in other life situations. A lawyer does not work for only one client at a time, for example. While one case is waiting to go to trial or have papers typed, the lawyer can work on another case. If he has enough clients, the lawyer will never be idle for lack of work. (Idle lawyers tend to become politicians, so there is a certain social value in keeping lawyers busy.) 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 Multiprogrammed systems provide an environment in which the various system resources (for example, 
\fs24 CPU
\fs26\fsmilli13333 , memory, and peripheral devices) are utilized effectively, but they do not provide for user interaction with the computer system. 
\f1\fs24 \cf4 \
\
\
\

\f0\b\fs26\fsmilli13333 \cf3 Time sharing 
\b0 \cf2 (or 
\b \cf3 multitasking
\b0 \cf2 ) is a logical extension of multiprogramming. In time-sharing systems, the 
\fs24 CPU 
\fs26\fsmilli13333 executes multiple jobs by switching among them, but the switches occur so frequently that the users can interact with each program while it is running. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 Time sharing requires an 
\b \cf3 interactive 
\b0 \cf2 computer system, which provides direct communication between the user and the system. The user gives instructions to the operating system or to a program directly, using a input device such as a keyboard, mouse, touch pad, or touch screen, and waits for immediate results on an output device. Accordingly, the 
\b \cf3 response time 
\b0 \cf2 should be short\'97typically less than one second. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 A time-shared operating system allows many users to share the computer simultaneously. Since each action or command in a time-shared system tends to be short, only a little 
\fs24 CPU 
\fs26\fsmilli13333 time is needed for each user. As the system switches rapidly from one user to the next, each user is given the impression that the entire computer system is dedicated to his use, even though it is being shared among many users. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 A time-shared operating system uses 
\fs24 CPU 
\fs26\fsmilli13333 scheduling and multiprogram- ming to provide each user with a small portion of a time-shared computer. Each user has at least one separate program in memory. A program loaded into memory and executing is called a 
\b \cf3 process
\b0 \cf2 . When a process executes, it typically executes for only a short time before it either finishes or needs to perform 
\fs24 I/O
\fs26\fsmilli13333 . 
\fs24 I/O 
\fs26\fsmilli13333 may be interactive; that is, output goes to a display for the user, and input comes from a user keyboard, mouse, or other device. Since interactive 
\fs24 I/O 
\fs26\fsmilli13333 typically runs at 
\f1 \cf2 \'93
\f0 \cf2 people speeds,
\f1 \cf2 \'94 
\f0 \cf2 it may take a long time to complete. Input, for example, may be bounded by the user\'92s typing speed; seven characters per second is fast for people but incredibly slow for computers. Rather than let the 
\fs24 CPU 
\fs26\fsmilli13333 sit idle as this interactive input takes place, the operating system will rapidly switch the 
\fs24 CPU 
\fs26\fsmilli13333 to the program of some other user. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 Time sharing and multiprogramming require that several jobs be kept simultaneously in memory. If several jobs are ready to be brought into memory, and if there is not enough room for all of them, then the system must choose among them. Making this decision involves 
\b \cf3 job scheduling
\b0 \cf2 , which we discuss in Chapter 6. When the operating system selects a job from the job pool, it loads that job into memory for execution. Having several programs in memory at the same time requires some form of memory management, which we cover in Chapters 8 and 9. In addition, if several jobs are ready to run at the same time, the system must choose which job will run first. Making this decision is 
\b\fs24 \cf3 CPU 
\fs26\fsmilli13333 \cf3 scheduling
\b0 \cf2 , which is also discussed in Chapter 6. Finally, running multiple jobs concurrently requires that their ability to affect one another be limited in all phases of the operating system, including process scheduling, disk storage, and memory management. We discuss these considerations throughout the text. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 In a time-sharing system, the operating system must ensure reasonable response time. This goal is sometimes accomplished through 
\b \cf3 swapping
\b0 \cf2 , whereby processes are swapped in and out of main memory to the disk. A more common method for ensuring reasonable response time is 
\b \cf3 virtual memory
\b0 \cf2 , a technique that allows the execution of a process that is not completely in memory (Chapter 9). The main advantage of the virtual-memory scheme is that it enables users to run programs that are larger than actual 
\b \cf3 physical memory
\b0 \cf2 . Further, it abstracts main memory into a large, uniform array of storage, separating 
\b \cf3 logical memory 
\b0 \cf2 as viewed by the user from physical memory. This arrangement frees programmers from concern over memory-storage limitations. 
\f1\fs24 \cf4 \

\f0\fs26\fsmilli13333 \cf2 A time-sharing system must also provide a file system (Chapters 11 and 12). The file system resides on a collection of disks; hence, disk management must be provided (Chapter 10). In addition, a time-sharing system provides a mechanism for protecting resources from inappropriate use (Chapter 14). To ensure orderly execution, the system must provide mechanisms for job synchronization and communication (Chapter 5), and it may ensure that jobs do not get stuck in a deadlock, forever waiting for one another (Chapter 7). 
\f1\fs24 \cf4 \
}